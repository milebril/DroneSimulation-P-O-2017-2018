package autopilotModule;

import java.util.ArrayList;

import autopilot.algorithmHandler.AutopilotAlain;
import autopilot.interfaces.Autopilot;
import autopilot.interfaces.AutopilotConfig;
import autopilot.interfaces.AutopilotFactory;
import autopilot.interfaces.AutopilotInputs;
import autopilot.interfaces.AutopilotModule;
import autopilot.interfaces.AutopilotOutputs;
import autopilotModule.Testbed;
import entities.Drone;
import models.Airport;
import models.RawModel;
import models.TexturedModel;
import physicsEngine.PhysicsEngine;
import physicsEngine.approximationMethods.EulerPrediction;
import renderEngine.Loader;
import renderEngine.OBJLoader;
import textures.ModelTexture;

public class Module implements AutopilotModule{
	
	private static final float STEP_TIME = 0.001f;
	private static Loader loader;
	
	private float length;
	private float width;
	
	private Testbed testbed;
	
	
	private ArrayList<AutopilotOutputs> apOutputs;
	


	
	
	public Module(Testbed testbed) {
		setTestbed(testbed);

	};
	

	@Override
	public void defineAirportParams(float length, float width) {
		this.length = length;
		this.width = width;
		
	}

	@Override
	public void defineAirport(float centerX, float centerZ, float centerToRunway0X, float centerToRunway0Z) {
		// (centerToRunway0X, centerToRunway0Z) constitutes a unit vector pointing from the center of the airport towards runway 0
		Airport airport = new Airport((int) centerX, (int) centerZ, this.getTestbed().getAirports().size());
		this.getTestbed().getAirports().add(this.getTestbed().getAirports().size(), airport);
	}

	//TODO: moeten we drones bijhouden hier en dezelfde lijst int testbed? of wa moete we hier eigenlijk juist doen???
	@Override
	public void defineDrone(int airport, int gate, int pointingToRunway, AutopilotConfig config) {
		// airport and gate define the drone's initial location, pointingToRunway its initial orientation. The first drone that is defined is drone 0, etc.
		
		Airport luchthaven = this.getTestbed().getAirports().get(airport);
		loader = new Loader();
		RawModel droneModel = OBJLoader.loadObjModel("untitled5", loader);
		TexturedModel staticDroneModel = new TexturedModel(droneModel,
				new ModelTexture(loader.loadTexture("untitled")));
		Drone drone = new Drone(staticDroneModel, luchthaven.getDronePosition(gate, config),
				1f, config, new EulerPrediction(STEP_TIME));
		int droneId = this.getTestbed().getDrones(this.getTestbed().getInactiveDrones(),this.getTestbed().getActiveDrones()).size();
		this.getTestbed().getInactiveDrones().add(droneId, drone);
		
	}

	@Override
	public void startTimeHasPassed(int drone, AutopilotInputs inputs) {
		// Allows the autopilots for all drones to run in parallel if desired. Called with drone = 0 through N - 1, in that order, if N drones have been defined.
	
		this.apOutputs.add(drone, this.getTestbed().getActiveDrones().get(drone).getAutopilot().timePassed(inputs));
	}

	@Override
	public AutopilotOutputs completeTimeHasPassed(int drone) {
		// Called with drone = 0 through N - 1, in that order, if N drones have been defined.
		return apOutputs.get(drone);
	}

	@Override
	public void deliverPackage(int fromAirport, int fromGate, int toAirport, int toGate) {
		// Informs the autopilot module of a new package delivery request generated by the testbed.
		
		Integer distance = Integer.MAX_VALUE;
		Drone dBest = this.testbed.getInactiveDrones().get(0);
		
		for (Drone d : this.testbed.getInactiveDrones()) {
			
			if (true) {
				//als d korter is overschrijven, anders next
				//TODO: fix distance
			}
			//kortste afstand berekenen
		}
		
		this.getTestbed().getInactiveDrones().remove(dBest.hashCode());
		this.getTestbed().getActiveDrones().add(dBest.hashCode(), dBest);
		
	}

	@Override
	public void simulationEnded() {
		
		
	}


	public Testbed getTestbed() {
		return testbed;
	}


	public void setTestbed(Testbed testbed) {
		this.testbed = testbed;
	}

}
